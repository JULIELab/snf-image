#! /bin/bash

# Copyright (C) 2011-2018 GRNET S.A. and individual contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

### BEGIN TASK INFO
# Provides:		ChangePassword
# RunBefore:            EnforcePersonality
# RunAfter:		InstallUnattend & FilesystemResizeMounted
# Short-Description:	Changes Password for specified users
### END TASK INFO

set -e
. "@commondir@/common.sh"

task_init_as excludable mounted_excludable overwritable

linux_shadow="/etc/shadow"
freebsd_shadow="/etc/master.passwd"
openbsd_shadow="/etc/master.passwd"
netbsd_shadow="/etc/master.passwd"

linux_change_shadow_entry() {
    local line encrypted
    line="$1"
    encrypted="$2"

    IFS=":" read -a entry <<< "$line"

    echo "${entry[0]}:$encrypted:15103:0:99999:7:::"
}

freebsd_change_shadow_entry() {
    local line encrypted
    line="$1"
    encrypted="$2"

    IFS=":" read -a entry <<< "$line"

    echo "${entry[0]}:$encrypted:${entry[2]}:${entry[3]}:${entry[4]}:${entry[5]}:0:${entry[7]}:${entry[8]}:${entry[9]}"
}

openbsd_change_shadow_entry() {
    freebsd_change_shadow_entry "$@"
}

netbsd_change_shadow_entry() {
    freebsd_change_shadow_entry "$@"
}

windows_password() {
    local target password sam names wcm xpath unattend arch sysprepinf infedit
    target="$1"
    password="$2"
    sam="$target/windows/system32/config/sam"

    if [ !  -f "$sam" ]; then
        log_error "SAM file: $sam is missing"
    fi


    echo "@echo off" > "$target/Windows/SnfScripts/ChangeAdminPassword.cmd"

    if [ -z "$SNF_IMAGE_PROPERTY_USERS" ]; then
        warn "Image property \`USERS' is missing or empty. " \
            "Changing the password for default user: \`Administrator'."

        SNF_IMAGE_PROPERTY_USERS="Administrator"
    fi

    if [ "$SNF_IMAGE_PROPERTY_OSFAMILY" = 'windows-legacy' ]; then
        infedit=@scriptsdir@/handle-ini-file.py
        sysprepinf="$(get_sysprepinf "$target")"
        if [ -z "$sysprepinf" ]; then
            log_error "SYSPREP.INF answer file not found."
        fi

        # Change the Administrator password if not set. This needs to be done
        # in order to have an unattended installation. If the AdminPassword
        # entry is present, then maybe the user wants to leave it as is. If
        # not, he should have added "Administrator" to the USERS image
        # property.
        if [ -z "$($infedit "$sysprepinf" get GuiUnattended AdminPassword)" ]; then
            $infedit "$sysprepinf" set GuiUnattended AdminPassword "$password"
            $infedit "$sysprepinf" set GuiUnattended EncryptedAdminPassword No
        fi
    fi

    names="$($HIVEXREGEDIT --export "$sam" '\SAM\Domains\Account\Users\Names' \
             | gawk 'match($0, /Names\\([^\\]+)\]/, n) { print n[1]; }')"

    if [ "$SNF_IMAGE_PROPERTY_OSFAMILY" = 'windows' ]; then
        # Add the users that get created by the unattend.xml file

        unattend="$(get_unattend "$target")"
        if [ -z "$unattend" ]; then
            log_error "No unattend.xml file found in the image."
        fi
        arch="$(get_windows_architecture "$target")"
        if [ -z "$arch" ]; then
            log_error "Unable to determine Windows architecture"
        fi

        # Find the wcm namespace value
        wcm=$($XMLSTARLET sel -t  -v '(//namespace::*[name()="wcm"])[1]' "$unattend")

        xpath='/_:unattend/_:settings/_:component[@processorArchitecture="'$arch'"]/_:UserAccounts/'
        xpath+='_:LocalAccounts/_:LocalAccount[@wcm:action="add"]/_:Name'

        names+=$($XMLSTARLET sel -N wcm="$wcm" -t -v "$xpath" "$unattend") || true
    fi

    for usr in $SNF_IMAGE_PROPERTY_USERS; do
        if ! grep "$usr" >/dev/null <<< "$names"; then
            log_error "User: \`$usr' does not exist."
        fi
        echo -n "Installing new password for user \`$usr'..."
        echo "net user $usr $password /ACTIVE:YES /EXPIRES:NEVER /PASSWORDREQ:YES" >> \
            "$target/Windows/SnfScripts/ChangeAdminPassword.cmd"
        echo done
    done
}

unix_auth() {
    local flavor target password encrypted users usr tmp_shadow method home opt
    local default_method keys entry keys_file keys_file_tmpl new_entry uid guid
    local seed cfg

    while getopts 'f:k:m:p:t:' opt; do
        case $opt in
            f) flavor="$OPTARG"
                ;;
            k) keys="$OPTARG"
                ;;
            m) method="$OPTARG"
                ;;
            p) password="$OPTARG"
                ;;
            t) target="$OPTARG"
                ;;
            *) log_error "Invalid option -$OPTARGS in unix_auth"
                ;;
        esac
    done

    if [ -z "${flavor+dummy}" ]; then
        log_error "unix_auth: flavor (-f) parameter needed but missing"
    fi
    if [ -z "${target+dummy}" ]; then
        log_error "unix_auth: target (-t) parameter needed but missing"
    fi
    if [ -n "${password+dummy}" ]; then
        shadow="${flavor}_shadow"
        if [ ! -e "$target${!shadow}" ]; then
            log_error "No ${!shadow} found!"
        fi

        case "$flavor" in
            linux|freebsd)
                default_method=sha512
                ;;
            openbsd)
                default_method=blowfish
                ;;
            netbsd)
                default_method=sha1
                ;;
            *)
                log_error "Unknown unix flavor: \`$flavor'"
                ;;
        esac

        method="${method:-$default_method}"
        if [ "$method" != "none" ]; then
            echo -n "Encrypting password with \`$method' method ... "
            encrypted=$("@scriptsdir@/hashpwd.py" -m "$method" "$password")
            echo "done"
        else
            encrypted="$password"
        fi
    fi

    if check_yes_no SNF_IMAGE_PROPERTY_CLOUD_INIT; then
        seed=$(get_cloud_init_seed "$SNF_IMAGE_TARGET")
        cfg=$(get_cloud_init_config "$SNF_IMAGE_TARGET" "$CLOUD_INIT_CONFNAME" no)

        if [ -n "${password+dummy}" ]; then
            echo "ssh_pwauth: True" >> "$cfg"
        fi

        if [ -n "${keys+dummy}" ]; then
            echo "public-keys:" >> "$seed/meta-data"
            while read line; do
                # trim the line
                line="$(echo $line)"
                if [ -n "$line" ]; then
                    echo "  - $line" >> "$seed/meta-data"
                fi
            done <<< "${keys}"
        fi
    fi

    if [ -n "${keys}" ]; then
        # Find the value of the AuthorizedKeysFile keyword if present in
        # sshd_config. For more info check:
        # https://www.freebsd.org/cgi/man.cgi?sshd_config(5)
        if [ -f "${target}/etc/ssh/sshd_config" ]; then
            keys_file_tmpl=$(cut -d'#' -f1 "${target}/etc/ssh/sshd_config" |
                { egrep '\<AuthorizedKeysFile' || true; } |
                awk '{print $NF}')
        else
            warn "/etc/ssh/sshd_config is missing."
            keys_file_tmpl=
        fi
        keys_file_tmpl="$(printf "%q" "${keys_file_tmpl:-%h/.ssh/authorized_keys}")"
    fi

    declare -a users
    
    if [ -n "$SNF_IMAGE_PROPERTY_USERS" ]; then
        for usr in $SNF_IMAGE_PROPERTY_USERS; do
            users+=("$usr")
        done
    else
        warn "Image property \`USERS' is missing or empty. " \
            "Using default user: \`root'."
        users+=("root")
    fi

    if check_yes_no SNF_IMAGE_PROPERTY_CLOUD_INIT; then
        if [ -n "${password}" ]; then
            echo "chpasswd:" >> "$cfg"
            echo "  expire: false" >> "$cfg"
            echo "  list: |" >> "$cfg"
            for usr in "${users[@]}"; do
                echo "    ${usr}:${password}" >> "$cfg"
            done
        fi
        return
    fi

    for usr in "${users[@]}"; do

        if [ -n "${password+dummy}" ]; then
            echo -n "Setting ${usr} password ... "

            tmp_shadow="$(mktemp)"
            add_cleanup rm "$tmp_shadow"

            entry=$(grep "^${usr}:" "$target${!shadow}") || true
            if [ -z "$entry" ]; then
                log_error "User: \`${usr}' does not exist" \
                    "(not present in ${!shadow})."
            fi

            new_entry="$(${flavor}_change_shadow_entry "$entry" "$encrypted")"
            grep -v "^${usr}:" "$target${!shadow}" > "$tmp_shadow"
            echo "$new_entry" >> "$tmp_shadow"
            cat "$tmp_shadow" > "$target${!shadow}"

            echo "done"
        fi

        if [ -n "${keys+dummy}" ]; then
            echo -n "Adding authorization keys for user: \`${usr}' ... "

            IFS=':' read -ra entry <<<"$(grep "^${usr}:" "${target}/etc/passwd" || true)"
            if [ "${entry[0]}" != "${usr}" ]; then
                log_error "User: \`${usr}' does not exist" \
                        "(not present in /etc/passwd)"
            fi
            uid=${entry[2]}
            guid=${entry[3]}
            home=${entry[5]}

            keys_file="${keys_file_tmpl//%%/\$\\'%\'}"
            keys_file="${keys_file//%h/\$\{home\}}"
            keys_file="${keys_file//%u/\$\{usr\}}"
            eval keys_file=\"$keys_file\"

            if [ -z "$keys_file" ]; then
                log_error "Error while evaluating AuthorizedKeysFile: \`$keys_file'"
            fi

            # The man page states: this option may be set to ``none'' to skip
            # checking for user keys in files.
            if [ "$keys_file" = "none" ]; then
                log_warning "AuthorizedKeysFile is set to none. Not adding user keys in files"
                continue
            fi

            # After expansion, AuthorizedKeysFile is taken to be an absolute
            # path or one relative to the user's home directory.
            if ! [[ "$keys_file" = /* ]]; then
                keys_file="$home/$keys_file"
            fi

            mkdir -p "$(dirname "${target}${keys_file}")"
            chown "${uid}:${guid}" "$(dirname "${target}${keys_file}")"
            chmod 700 "$(dirname "${target}${keys_file}")"

            echo "$keys" >> "${target}${keys_file}"
            chown "${uid}:${guid}" "${target}${keys_file}"
            chmod 600 "${target}${keys_file}"

            echo "done"
        fi
    done
}

#trim users var
SNF_IMAGE_PROPERTY_USERS=$(echo $SNF_IMAGE_PROPERTY_USERS)

if [[ "$SNF_IMAGE_PROPERTY_OSFAMILY" =~ ^windows ]]; then
    if [ -n "${SNF_IMAGE_PASSWD_HASH+dummy}" ]; then
        log_error "On Windows images password hash is not applicable."
    fi

    if [ -n "${SNF_IMAGE_AUTH_KEYS+dummy}" ]; then
       warn "Injecting authorization keys is not supported for Windows"
    fi

    if [ -z "${SNF_IMAGE_PASSWD+dummy}" ]; then
        warn "Task ${PROGNAME:2} will not run. Password is not set"
        exit 0
    fi

    windows_password "$SNF_IMAGE_TARGET" "$SNF_IMAGE_PASSWD"
else
    ARGS=("-f" "$SNF_IMAGE_PROPERTY_OSFAMILY" "-t" "$SNF_IMAGE_TARGET")

    if [ -n "${SNF_IMAGE_PASSWD_HASH+dummy}" ]; then
        SNF_IMAGE_PROPERTY_PASSWD_HASHING_METHOD=none
        SNF_IMAGE_PASSWD="$SNF_IMAGE_PASSWD_HASH"
    fi

    if [ -n "${SNF_IMAGE_PASSWD+dummy}" ]; then
        ARGS+=("-p" "$SNF_IMAGE_PASSWD")
    fi

    if [ -n "${SNF_IMAGE_PROPERTY_PASSWD_HASHING_METHOD}" ]; then
        ARGS+=("-m" "${SNF_IMAGE_PROPERTY_PASSWD_HASHING_METHOD}")
    fi

    if [ -n "${SNF_IMAGE_AUTH_KEYS+dummy}" ]; then
        if [ -n "${SNF_IMAGE_AUTH_KEYS}" ]; then
            ARGS+=("-k" "$SNF_IMAGE_AUTH_KEYS")
        else
            warn "Ignoring empty AUTH_KEYS parameter"
        fi
    fi

    if [ -z "${SNF_IMAGE_PASSWD+dummy}" -a -z "${SNF_IMAGE_AUTH_KEYS}" ]; then
        warn "Task: \`${PROGNAME:2} will not run. No password or key is set"
        exit 0
    fi

    unix_auth "${ARGS[@]}"
fi

# For FreeBSD, OpenBSD and NetBSD we need to recreate the password databases
if [[ "$SNF_IMAGE_PROPERTY_OSFAMILY" == *bsd ]]; then
    rm -f "$SNF_IMAGE_TARGET/etc/spwd.db"

    # NetBSD is very strict about the existence & non-existence of the db files
    if [ "$SNF_IMAGE_PROPERTY_OSFAMILY" = "netbsd" ]; then
        rm -f "$SNF_IMAGE_TARGET/etc/pwd.db.tmp"
        rm -f "$SNF_IMAGE_TARGET/etc/spwd.db.tmp"

        touch "$SNF_IMAGE_TARGET/etc/spwd.db"
    fi


    # Make sure /etc/spwd.db is recreated on first boot
    rc_local=$(cat <<EOF
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin
export PATH

pwd_mkdb -p /etc/master.passwd
EOF
)
    if [ -e "$SNF_IMAGE_TARGET/etc/rc.local" ]; then
        orig_local="/etc/rc.local.snf_image_$RANDOM"
        mv "$SNF_IMAGE_TARGET/etc/rc.local" "$SNF_IMAGE_TARGET$orig_local"
        cat > "$SNF_IMAGE_TARGET/etc/rc.local" <<EOF
$rc_local
mv $orig_local /etc/rc.local
. /etc/rc.local
EOF
    else
        cat > "$SNF_IMAGE_TARGET/etc/rc.local" <<EOF
$rc_local
rm -f /etc/rc.local
exit 0
EOF
    fi
fi

exit 0

# vim: set sta sts=4 shiftwidth=4 sw=4 et ai :

