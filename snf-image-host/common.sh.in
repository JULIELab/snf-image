# Copyright (C) 2011 GRNET S.A. 
# Copyright (C) 2007, 2008, 2009 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

AWK="awk"
KPARTX="kpartx"
LOSETUP="losetup"
SFDISK="sfdisk"
QEMU_IMG="qemu-img"
INSTALL_MBR="install-mbr"
TIMEOUT="timeout"
CURL="curl"

# Temporary use stderr as monitoring file descriptor.
# `create' will overwrite this
MONITOR_FD="2"

network_backend_support="@network_backend_support@"

MSG_TYPE_ERROR="image-error"
MSG_TYPE_INFO="image-info"

CLEANUP=( )
ERROR_MSGS=( )

add_cleanup() {
    local cmd=""
    for arg; do cmd+=$(printf "%q " "$arg"); done
    CLEANUP+=("$cmd")
}

log_error() {
    ERROR_MSGS+=("$@")
    echo "$*" >&2
}


log_info() {
    echo "$*" >&2

    local report="$(./host-monitor.py info <<< "$*")"

    eval "echo $(printf "%q" "$report") >&${MONITOR_FD}"
}


close_fd() {
    local fd="$1"
    exec {fd}>&-
}

report_error() {
    local error_file=$1
    local report=""
    if [ ${#ERROR_MSGS[@]} -gt 0 ]; then
        local msg=""
        for err in "${ERROR_MSGS[@]}"; do
            msg+="$(echo "$err")"
        done
        report="$(./host-monitor.py error <<< "$msg")"
    else
        report=$(tail -10 "$error_file" | ./host-monitor.py stderr)
    fi

    eval "echo $(printf "%q" "$report") >&${MONITOR_FD}"
}

get_api5_arguments() {
    GETOPT_RESULT=$*
    # Note the quotes around `$TEMP': they are essential!
    eval set -- "$GETOPT_RESULT"
    while true; do
        case "$1" in
            -i|-n) instance=$2; shift 2;;

            -o) old_name=$2; shift 2;;

            -b) blockdev=$2; shift 2;;

            -s) swapdev=$2; shift 2;;

            --) shift; break;;

            *)  log_error "Internal error!" >&2; exit 1;;
        esac
    done
    if [ -z "$instance" -o -z "$blockdev" ]; then
        log_error "Missing OS API Argument (-i, -n, or -b)"
        exit 1
    fi
    if [ "$SCRIPT_NAME" != "export" -a -z "$swapdev"  ]; then
        log_error "Missing OS API Argument -s (swapdev)"
        exit 1
    fi
    if [ "$SCRIPT_NAME" = "rename" -a -z "$old_name"  ]; then
        log_error "Missing OS API Argument -o (old_name)"
        exit 1
    fi
}

get_api10_arguments() {
    if [ -z "$INSTANCE_NAME" -o -z "$HYPERVISOR" -o -z "$DISK_COUNT" ]; then
        log_error "Missing OS API Variable:"
        log_error "(INSTANCE_NAME HYPERVISOR or DISK_COUNT)"
        exit 1
    fi
    instance=$INSTANCE_NAME
    if [ $DISK_COUNT -lt 1 -o -z "$DISK_0_PATH" ]; then
        log_error "At least one disk is needed"
        exit 1
    fi
    if [ "$SCRIPT_NAME" = "export" ]; then
        if [ -z "$EXPORT_DEVICE" ]; then
            log_error "Missing OS API Variable EXPORT_DEVICE"
        fi
        blockdev=$EXPORT_DEVICE
    elif [ "$SCRIPT_NAME" = "import" ]; then
        if [ -z "$IMPORT_DEVICE" ]; then
        log_error "Missing OS API Variable IMPORT_DEVICE"
        fi
        blockdev=$IMPORT_DEVICE
    else
        blockdev=$DISK_0_PATH
    fi
    if [ "$SCRIPT_NAME" = "rename" -a -z "$OLD_INSTANCE_NAME" ]; then
        log_error "Missing OS API Variable OLD_INSTANCE_NAME"
    fi
    old_name=$OLD_INSTANCE_NAME
}

get_api20_arguments() {
    get_api10_arguments

    local required_osparams="IMG_ID IMG_FORMAT IMG_PASSWD"
    local osparams="$required_osparams IMG_PROPERTIES IMG_PERSONALITY CONFIG_URL"

    # Store OSP_VAR in VAR
    for param in $osparams; do
        eval $param=\"\$OSP_$param\"
    done

    if [ -n "$CONFIG_URL" ]; then
	source <($CURL -f "$CONFIG_URL" | ./decode-config.py $osparams)
    fi

    for var in $required_osparams; do
        if [ -z "${!var}" ]; then
             log_error "Missing OS API Parameter: ${var}"
             exit 1
        fi
    done
}

map_disk0() {
    blockdev="$1"
    filesystem_dev_base=$($KPARTX -l -p- $blockdev | \
                            grep -m 1 -- "-1.*$blockdev" | \
                            $AWK '{print $1}')
    if [ -z "$filesystem_dev_base" ]; then
        log_error "Cannot interpret kpartx output and get partition mapping"
        exit 1
    fi
    $KPARTX -a -p- "$blockdev" > /dev/null
    filesystem_dev="/dev/mapper/${filesystem_dev_base/%-1/}"
    if [ ! -b "/dev/mapper/$filesystem_dev_base" ]; then
        log_error "Can't find kpartx mapped partition:" \
                                            "/dev/mapper/$filesystem_dev_base"
        exit 1
    fi
    echo "$filesystem_dev"
}

unmap_disk0() {
    $KPARTX -d -p- "$1"
}

format_disk0() {
    local device="$1"
    local image_type="$2"

    declare -A part_id=( ['extdump']="83" ["ntfsdump"]="7" )

    # The -f is needed, because we use an optimal alignment and sfdisk complains
    # about partitions not ending on clylinder boundary.
    local sfdisk_cmd="$SFDISK -uS -H 255 -S 63 -f --quiet --Linux --DOS $device"

    $sfdisk_cmd > /dev/null <<EOF
2048,,${part_id["$image_type"]},*
EOF
}

create_floppy() {
    local img=$1

    local target=$(mktemp -d)
    add_cleanup rmdir "$target"

    dd bs=512 count=2880 if=/dev/zero of="$img"
    mkfs.ext2 -F "$img" > /dev/null
    mount "$img" "$target" -o loop
    set | egrep ^snf_export_\\w+= | sed -e 's/^snf_export_/export SNF_IMAGE_/' \
        > "$target/rules"
    if [ -n "$UNATTEND" ]; then
        if [ -f "$UNATTEND" ]; then
            cat "$UNATTEND" > "$target/unattend.xml"
        else
            log_error "Unattend file: \`"$UNATTEND"' does not exist"
        fi
    fi
    umount "$target"
}

get_backend_type() {
    local id=$1

    if [[ "$id" =~ ^pithos: ]]; then
        echo "pithos"
    elif [[ "$id" =~ ^(http|ftp)s?: ]]; then
        if [ "$network_backend_support" = "yes" ]; then
            echo "network";
        else
            log_error "Retrieving images from the network is not supported."
            exit 1
        fi
    elif [ "$id" = "null" ]; then
        echo "null"
    else
        echo "local"
    fi
}

# this one is only to be called by create
ganeti_os_main() {
    if [ -z "$OS_API_VERSION" -o "$OS_API_VERSION" = "5" ]; then
        OS_API_VERSION=5
        GETOPT_RESULT=`getopt -o o:n:i:b:s: -n '$0' -- "$@"`
        if [ $? != 0 ] ; then log_error "Terminating..."; exit 1 ; fi
        get_api5_arguments $GETOPT_RESULT
    elif [ "$OS_API_VERSION" = "10" -o "$OS_API_VERSION" = "15" ]; then
        get_api10_arguments
    elif [ "$OS_API_VERSION" = "20" ]; then
        get_api20_arguments
        IMAGE_NAME="$IMG_ID"
        IMAGE_TYPE="$IMG_FORMAT"
        BACKEND_TYPE=$(get_backend_type $IMG_ID)
    else
        log_error "Unknown OS API VERSION $OS_API_VERSION"
        exit 1
    fi
    
    if [ -n "$OS_VARIANT" ]; then
        if [ ! -d "$VARIANTS_DIR" ]; then
            log_error "OS Variants directory $VARIANTS_DIR doesn't exist"
            exit 1
        fi
        VARIANT_CONFIG="$VARIANTS_DIR/$OS_VARIANT.conf"
        if [ -f "$VARIANT_CONFIG" ]; then
            . "$VARIANT_CONFIG"
        else
            if grep -qxF "$OS_VARIANT" variants.list; then
                log_error "ERROR: instance-image configuration error"
                log_error "  Published variant $OS_VARIANT is missing its" \
                    "config file"
                log_error "  Please create $VARIANT_CONFIG or unpublish the" \
                    "variant"
                log_error "  (by removing $OS_VARIANT from variants.list)"
            else
                log_error "Unofficial variant $OS_VARIANT is unsupported"
                log_error "Most probably this is a user error, forcing a" \
                    "wrong name"
                log_error "To support this variant please create file" \
                    "$VARIANT_CONFIG"
            fi
            exit 1
        fi
    fi

}

do_debootstrap() {
    local target="$1"

    echo "Debootstraping to create a new root filesystem:"

    # Create a policy-rc.d file to deny init script execution
    mkdir -p "$target/usr/sbin"
    cat > "$target/usr/sbin/policy-rc.d" <<EOF
#!/bin/sh
exit 101
EOF
    chmod +x "$target/usr/sbin/policy-rc.d"

    debootstrap --arch $(dpkg --print-architecture) \
        --include "$HELPER_EXTRA_PKGS" --variant=minbase stable "$target" \
        "$HELPER_MIRROR" 2>&1 | sed -e 's/^/DEBOOTSTRAP: /g'

    # Save the package list
    chroot "$target" dpkg-query -W -f "\${Package}\n" > "$HELPER_CACHE_PKGS"

    rm "$target/usr/sbin/policy-rc.d"

    # remove the downloaded debs, as they are no longer needed
    find "$target/var/cache/apt/archives" -type f -name '*.deb' -print0 | \
        xargs -r0 rm -f

    local tmp_cache=$(mktemp "$CACHE_FILE.XXXXXX")
    tar cf "$tmp_cache" --one-file-system -C "$target" . || \
        { rm "$tmp_cache"; false; }
    # Overwrite the default cache file. Not the user specified if present.
    mv -f "$tmp_cache" "$HELPER_CACHE_FILE"
}

report_and_cleanup(){

    local err_file="$1"

    report_error "$err_file"
    cleanup
}

cleanup() {
    # if something fails here, it souldn't call cleanup again...
    trap - EXIT

    if [ ${#CLEANUP[*]} -gt 0 ]; then
        LAST_ELEMENT=$((${#CLEANUP[*]}-1))
        REVERSE_INDEXES=$(seq ${LAST_ELEMENT} -1 0)
        for i in $REVERSE_INDEXES; do
            # If something fails here, it's better to retry it for a few times
            # before we give up with an error. This is needed for kpartx when
            # dealing with ntfs partitions mounted through fuse. umount is not
            # synchronous and may return while the partition is still busy. A
            # premature attempt to delete partition mappings through kpartx on
            # a device that hosts previously mounted ntfs partition may fail
            # with errors like this one:
            # `device-mapper: remove ioctl failed: Device or resource busy'
            # A sensible workaround for this is to wait for a while and then
            # retry it.
            local cmd=${CLEANUP[$i]}
            $cmd || for interval in 0.25 0.5 1 2 4; do
            echo "Command $cmd failed!"
            echo "I'll wait for $interval secs and will retry..."
            sleep $interval
            $cmd && break
        done
        if [ "$?" != "0" ]; then
            echo "Giving Up..."
            exit 1;
        fi
    done
  fi
}

trap cleanup EXIT

DEFAULT_FILE="@sysconfdir@/default/snf-image"
if [ -f "$DEFAULT_FILE" ]; then
    . "$DEFAULT_FILE"
fi

: ${VARIANTS_DIR:="@sysconfdir@/ganeti/snf-image/variants"}
: ${IMAGE_DIR:="@localstatedir@/lib/snf-image"}
: ${HELPER_DIR:="@HELPER_DIR@"}
: ${HELPER_IMG:="@HELPER_IMG@"}
: ${HELPER_KERNEL:="@HELPER_KERNEL@"}
: ${HELPER_INITRD:="@HELPER_INITRD@"}
: ${HELPER_PKG:="@HELPER_DIR@/snf-image-helper.deb"}
: ${HELPER_SOFT_TIMEOUT:=20}
: ${HELPER_HARD_TIMEOUT:=5}
: ${HELPER_USER:="nobody"}
: ${HELPER_CACHE_FILE:="@HELPER_DIR@/cache.tar"}
: ${HELPER_CACHE_PKGS:="@HELPER_DIR@/packages"}
: ${HELPER_EXTRA_PKGS:="linux-image-amd64,e2fsprogs,ntfs-3g,ntfsprogs,xmlstarlet,python,parted,reglookup,chntpw,util-linux"}
: ${HELPER_MIRROR:=""}
: ${PITHOS_DB:="sqlite:////@localstatedir@/lib/pithos/backend.db"}
: ${PITHOS_DATA:="@localstatedir@/lib/pithos/data/"}
: ${PROGRESS_MONITOR:="@PROGRESS_MONITOR@"}
: ${UNATTEND:="@UNATTEND@"}

SCRIPT_NAME=$(basename $0)

# vim: set sta sts=4 shiftwidth=4 sw=4 et ai :
